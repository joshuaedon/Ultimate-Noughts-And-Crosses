/* autogenerated by Processing revision 1277 on 2021-10-11 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Ultimate_noughts_and_crosses extends PApplet {

// Game settings
int n = 3;

// Sizes
int margin = 20;

int w,h;
float minDim;
float cellSize;

// Dynamic
int turn;

PVector curSubgrid;

SmallGrid overallGame;

SmallGrid[][] detailedGame;

int overallVictor;

 public void setup() {
  /* size commented out by preprocessor */;
  
  surface.setResizable(true);
  registerMethod("pre", this);
  minDim = min(width, height);
  
  reset();
}

 public void keyPressed() {
    if(key == 'r')
      reset();
    if(keyCode > '0' && keyCode <= '9') {
      n = keyCode - '0';
      cellSize = (minDim - 2 * margin) / (n * n);
      reset();
    }
}

 public void reset() {
  turn = 0;
  
  curSubgrid = new PVector(-1, -1);
  
  overallGame = new SmallGrid(n);
  
  detailedGame = new SmallGrid[n][n];
  
  // Populate the detailed game with small grids
  for(int i = 0; i < n; i++) {
    for(int j = 0; j < n; j++) {
      detailedGame[i][j] = new SmallGrid(n);
    }
  }
  
  overallVictor = -1;
}

// Update size values when the window size is changed
 public void pre() {
  if (w != width || h != height) {
    // Sketch window has resized
    w = width;
    h = height;
    
    minDim = min(width, height);
    cellSize = (minDim - 2 * margin) / (n * n);
  }
}

 public void draw() {
  background(255);
  
  fill(0);
  textSize(15);
  text("Press numbers to change the grid size and 'r' to reset the game.", 5, height - 5);
  
  highlightAvailable();
  drawGrid();
  highlightCell();
  populateGrid();
  
  if(overallVictor > -1)
    overallGame.drawWinningLine(cellSize, margin);
}

 public void highlightAvailable() {
  if(overallVictor > -1)
    return;
  
  if(curSubgrid.x < 0) {
    for(int i = 0; i < n; i++) {
      for(int j = 0; j < n; j++) {
        PVector superDims = new PVector(i, j);
        detailedGame[i][j].highlightAvailable(superDims, cellSize, margin);
      }
    }
  } else {
    detailedGame[PApplet.parseInt(curSubgrid.x)][PApplet.parseInt(curSubgrid.y)].highlightAvailable(curSubgrid, cellSize, margin);
  }
}

// Draw the lines of the grid
 public void drawGrid() {
  stroke(0);
  for(int i = 0; i <= (n * n); i++) {
    if(i % n == 0)
      strokeWeight(3);
    else
      strokeWeight(1);
    
    float len = i * cellSize;
    line(margin, margin + len, minDim - margin, margin + len);
  }
  for(int i = 0; i <= (n * n); i++) {
    if(i % n == 0)
      strokeWeight(3);
    else
      strokeWeight(1);
    
    float len = i * cellSize;
    line(margin + len, margin, margin + len, minDim - margin);
  }
}

// Draw the noughts and crosses in each subgrid
 public void populateGrid() {
  for(int i = 0; i < n; i++) {
    for(int j = 0; j < n; j++) {
      PVector superDims = new PVector(i, j);
      detailedGame[i][j].populateGrid(overallGame.grid[i][j], superDims, cellSize, margin);
    }
  }
}

// Highlight the cell which the mouse is over (if 
 public void highlightCell() {
  if(overallVictor > -1)
    return;
  
  PVector mouseCoords = getMouseCoords();
  if(mouseCoords == null)
    return;
  if(!correctCell(mouseCoords))
    return;
    
  //strokeWeight(4);
  //fill(0, 0, 0, 0);
  //square(margin + mouseCoords.x * cellSize, margin + mouseCoords.y * cellSize, cellSize);
  
  // Draw symbol in grey
  stroke(200);
  noFill();
  strokeWeight(3);
  if(turn == 0) {
    float xOffset = (mouseCoords.x + 0.5f) * cellSize + margin;
    float yOffset = (mouseCoords.y + 0.5f) * cellSize + margin;
    
    ellipse(xOffset, yOffset, cellSize * 0.75f, cellSize * 0.75f);
  } else {
    float xOffset = mouseCoords.x * cellSize + margin;
    float yOffset = mouseCoords.y * cellSize + margin;
    
    line(xOffset + cellSize * 0.2f, yOffset + cellSize * 0.2f, xOffset + cellSize * 0.8f, yOffset + cellSize * 0.8f);
    line(xOffset + cellSize * 0.8f, yOffset + cellSize * 0.2f, xOffset + cellSize * 0.2f, yOffset + cellSize * 0.8f);
  }
}

 public void mousePressed() {
  if(overallVictor > -1)
    return;
  
  PVector mouseCoords = getMouseCoords();
  if(mouseCoords == null)
    return;
  if(!correctCell(mouseCoords))
    return;
  
  SmallGrid subGame = detailedGame[floor(mouseCoords.x / n)][floor(mouseCoords.y / n)];
  subGame.inputValue(PApplet.parseInt(mouseCoords.x) % n, PApplet.parseInt(mouseCoords.y) % n, turn);
  
  curSubgrid.x = PApplet.parseInt(mouseCoords.x) % n;
  curSubgrid.y = PApplet.parseInt(mouseCoords.y) % n;
  if(detailedGame[PApplet.parseInt(curSubgrid.x)][PApplet.parseInt(curSubgrid.y)].filled)
    curSubgrid = new PVector(-1, -1);
   
  if(overallGame.grid[floor(mouseCoords.x / n)][floor(mouseCoords.y / n)] < 0) {
    int victor = subGame.findVictor();
    if(victor >= 0) {
      overallGame.grid[floor(mouseCoords.x / n)][floor(mouseCoords.y / n)] = victor;
      
      // Check if the whole game has been won
      overallVictor = overallGame.findVictor();
      if(overallVictor > -1) {
        if(overallVictor == 0)
          println("Noughts win!");
        else
          println("Crosses win!");
        println("Press 'r' to restart");
        println("Press a number to change the size of the game");
      }
    }
  }
  
  turn = (turn + 1) % 2;
}

 public PVector getMouseCoords() {
  int cellX = floor((mouseX - margin) / cellSize);
  if(cellX < 0 || cellX >= (n * n))
    return null;
  
  int cellY = floor((mouseY - margin) / cellSize);
  if(cellY < 0 || cellY >= (n * n))
    return null;
   
  return new PVector(cellX, cellY);
}

// Assumes that the mouseCoords are witin the larger grid
 public boolean correctCell(PVector coords) {
  int xSuperCoord = floor(coords.x / n);
  int ySuperCoord = floor(coords.y / n);
  // Check valid superCoord
  if(curSubgrid.x == -1 || (xSuperCoord == curSubgrid.x && ySuperCoord == curSubgrid.y)) {
    // Check if cell is already populated
    SmallGrid subGame = detailedGame[xSuperCoord][ySuperCoord];
    int xSubCoord = PApplet.parseInt(coords.x) % n;
    int ySubCoord = PApplet.parseInt(coords.y) % n;
    if(subGame.grid[xSubCoord][ySubCoord] < 0)
      return true;
  }
  return false;
}
class SmallGrid {
  int[][] grid;
  
  boolean filled = false;
  PVector winStart;
  PVector winEnd;
  
  SmallGrid(int n) {
    grid = new int[n][n];
    
    for(int i = 0; i < n; i++) {
      for(int j = 0; j < n; j++) {
        grid[i][j] = -1;
      }
    }
  }
  
   public void printValues() {
    for(int i = 0; i < grid.length; i++) {
      for(int j = 0; j < grid[0].length; j++) {
        print(grid[i][j] + ", ");
      }
      println("");
    }
  }
  
   public void highlightAvailable(PVector superDims, float cellSize, int margin) {
    noStroke();
    fill(207, 238, 250);
    for(int i = 0; i < n; i++) {
      for(int j = 0; j < n; j++) {
        if(grid[i][j] < 0) {
          float xOffset = (superDims.x * n + i) * cellSize + margin;
          float yOffset = (superDims.y * n + j) * cellSize + margin;
          
          square(xOffset, yOffset, cellSize);
        }
      }
    }
  }
  
   public void populateGrid(int won, PVector superDims, float cellSize, int margin) {
    int n = grid.length;
    
    if(won < 0 && !filled)
      stroke(0);
    else
      stroke(200);
    strokeWeight(3);
    noFill();
    
    // Draw small symbols
    for(int i = 0; i < n; i++) {
      for(int j = 0; j < n; j++) {
        if(grid[i][j] == 0) {
          float xOffset = (superDims.x * n + i + 0.5f) * cellSize + margin;
          float yOffset = (superDims.y * n + j + 0.5f) * cellSize + margin;
          
          ellipse(xOffset, yOffset, cellSize * 0.75f, cellSize * 0.75f);
        } else if(grid[i][j] == 1) {
          float xOffset = (superDims.x * n + i) * cellSize + margin;
          float yOffset = (superDims.y * n + j) * cellSize + margin;
          
          line(xOffset + cellSize * 0.2f, yOffset + cellSize * 0.2f, xOffset + cellSize * 0.8f, yOffset + cellSize * 0.8f);
          line(xOffset + cellSize * 0.8f, yOffset + cellSize * 0.2f, xOffset + cellSize * 0.2f, yOffset + cellSize * 0.8f);
        }
      }
    }
    
    if(won >= 0) {
      strokeWeight(4);
      
      float xStart = (superDims.x * n + winStart.x + 0.5f) * cellSize + margin;
      float yStart = (superDims.y * n + winStart.y + 0.5f) * cellSize + margin;
      float xEnd = (superDims.x * n + winEnd.x + 0.5f) * cellSize + margin;
      float yEnd = (superDims.y * n + winEnd.y + 0.5f) * cellSize + margin;
      
      line(xStart, yStart, xEnd, yEnd);
    }
    
    // Draw large symbols if one player has how the subgrid
    if(won == 0) {
      stroke(0);
      strokeWeight(5);
      
      float xOffset = (superDims.x + 0.5f) * cellSize * n + margin;
      float yOffset = (superDims.y + 0.5f) * cellSize * n + margin;
      
      ellipse(xOffset, yOffset, cellSize * n * 0.75f, cellSize * n * 0.75f);
    } else if(won == 1) {
      stroke(0);
      strokeWeight(5);
      
      float xOffset = superDims.x * n * cellSize + margin;
      float yOffset = superDims.y * n * cellSize + margin;
      
      line(xOffset + cellSize * n * 0.2f, yOffset + cellSize * n * 0.2f, xOffset + cellSize * n * 0.8f, yOffset + cellSize * n * 0.8f);
      line(xOffset + cellSize * n * 0.8f, yOffset + cellSize * n * 0.2f, xOffset + cellSize * n * 0.2f, yOffset + cellSize * n * 0.8f);
    }
      
  }
  
   public void inputValue(int i, int j, int turn) {
    grid[i][j] = turn;
    checkFilled();
  }
  
   public void checkFilled() {
    for(int i = 0; i < n; i++) {
      for(int j = 0; j < n; j++) {
        if(grid[i][j] < 0)
          return;
      }
    }
    filled = true;
  }
  
   public int findVictor() {
    for(int i = 0; i < grid.length; i++) {
      int player = grid[i][0];
      // Skip if no player has taken the fisrt cell of the column
      if(player < 0)
        continue;
      boolean match = true;
      for(int j = 1; j < grid[0].length; j++) {
        if(grid[i][j] != player){
          match = false;
          break;
        }
      }
      if(match) {
        winStart = new PVector(i, -0.4f);
        winEnd = new PVector(i, grid.length - 0.6f);
        return player;
      }
    }
    
    for(int j = 0; j < grid[0].length; j++) {
      int player = grid[0][j];
      // Skip if no player has taken the fisrt cell of the row
      if(player < 0)
        continue;
      boolean match = true;
      for(int i = 1; i < grid.length; i++) {
        if(grid[i][j] != player){
          match = false;
          break;
        }
      }
      if(match) {
        winStart = new PVector(-0.4f, j);
        winEnd = new PVector(grid[0].length - 0.6f, j);
        return player;
      }
    }
    
    int player = grid[0][0];
    // Skip if no player has taken the fisrt cell of the column
    if(player >= 0) {
      boolean match = true;
      for(int i = 1; i < grid.length; i++) {
        if(grid[i][i] != player){
          match = false;
          break;
        }
      }
      if(match) {
        winStart = new PVector(-0.4f, -0.4f);
        winEnd = new PVector(grid.length - 0.6f, grid.length - 0.6f);
        return player;
      }
    }
    
    player = grid[0][grid.length - 1];
    // Skip if no player has taken the fisrt cell of the column
    if(player >= 0) {
      boolean match = true;
      for(int i = 1; i < grid.length; i++) {
        if(grid[i][grid.length - i - 1] != player){
          match = false;
          break;
        }
      }
      if(match) {
        winStart = new PVector(-0.4f, grid.length - 0.6f);
        winEnd = new PVector(grid.length - 0.6f, -0.4f);
        return player;
      }
    }
    
    return -1;
  }
  
   public void drawWinningLine(float cellSize, int margin) {
    stroke(0);
    strokeWeight(8);
    
    float xStart = (winStart.x + 0.5f) * cellSize * n + margin;
    float yStart = (winStart.y + 0.5f) * cellSize * n + margin;
    float xEnd = (winEnd.x + 0.5f) * cellSize * n + margin;
    float yEnd = (winEnd.y + 0.5f) * cellSize * n + margin;
    
    line(xStart, yStart, xEnd, yEnd);
  }
}


  public void settings() { size(750, 750); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Ultimate_noughts_and_crosses" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
